<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Map Generator (China Optimized)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <style>
        body, html { height: 100%; margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #leaflet-map { height: 100%; width: 100%; z-index: 1; }
        .glass-panel { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1); }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .leaflet-draw-tooltip { z-index: 1000; }
        .coord-input { font-family: monospace; font-size: 0.75rem; }
        input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; border: none; width: 24px; height: 24px; padding: 0; overflow: hidden; border-radius: 4px; cursor: pointer; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; appearance: textfield; }
        @keyframes flash { 0% { background-color: #dbeafe; } 100% { background-color: white; } }
        .input-flash { animation: flash 0.3s ease-out; }
        .res-option { transition: all 0.2s; border: 1px solid #e5e7eb; }
        .res-option.active { background-color: #eff6ff; border-color: #3b82f6; color: #1d4ed8; }
        
        /* åœ°å›¾åˆ‡æ¢æŒ‰é’®æ ·å¼ */
        .map-switch {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 5px;
        }
        .map-btn {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid #ddd;
        }
        .map-btn.active {
            background-color: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
    </style>
</head>
<body>

<div id="app" class="h-full flex relative">
    
    <div class="w-96 h-full glass-panel z-20 flex flex-col border-r border-gray-200 shadow-xl overflow-y-auto absolute left-0 top-0">
        <div class="p-6">
            <h1 class="text-2xl font-bold text-gray-800 mb-2">Voronoi Map ğŸ› ï¸</h1>
            <p class="text-sm text-gray-500 mb-6">åŸºäº OSM/é«˜å¾· çš„åœ°ç†æ³°æ£®å¤šè¾¹å½¢ç”Ÿæˆå™¨</p>

            <div class="mb-6">
                <h2 class="block text-sm font-bold text-gray-800 mb-3 border-l-4 border-indigo-600 pl-2">1. åœ°å›¾æ•°æ®æº</h2>
                <div class="mb-2">
                    <label class="block text-xs font-medium text-gray-600 mb-1">ä¸»åº•å›¾ (GeoJSON / JSON)</label>
                    <input type="file" ref="fileInput" @change="e => validateFile(e, fileInput)" accept=".json,.geojson" 
                           class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                </div>
                <div class="ml-4 pl-3 border-l-2 border-gray-200 mt-3">
                    <div class="flex items-center justify-between mb-2">
                        <label class="text-xs font-medium text-gray-500">â””â”€ å åŠ è¾…åŠ©å›¾å±‚ (å¯é€‰)</label>
                        <div class="flex items-center">
                            <input type="checkbox" id="drawPlugin" v-model="drawPlugin" class="w-3 h-3 text-blue-600 rounded focus:ring-blue-500 cursor-pointer">
                            <label for="drawPlugin" class="ml-1.5 text-[10px] text-gray-500 font-medium cursor-pointer select-none">å¯ç”¨</label>
                        </div>
                    </div>
                    <div class="transition-all duration-300 ease-in-out" :class="drawPlugin ? 'opacity-100 max-h-20' : 'opacity-40 max-h-20 grayscale pointer-events-none'">
                        <input type="file" ref="pluginInput" @change="e => validateFile(e, pluginInput)" accept=".json,.geojson" 
                               class="block w-full text-[10px] text-gray-400 file:mr-2 file:py-1 file:px-3 file:rounded-full file:border-0 file:text-[10px] file:bg-gray-100 file:text-gray-600 hover:file:bg-gray-200"/>
                        <p class="text-[10px] text-gray-300 mt-1 italic">é€‚ç”¨äºçœç•Œã€æ°´ç³»ç­‰å åŠ è¦ç´ </p>
                    </div>
                </div>
            </div>

            <hr class="border-gray-100 mb-6">

            <div class="mb-6">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="block text-sm font-bold text-gray-800 border-l-4 border-indigo-600 pl-2">2. ç‚¹ä½ç®¡ç† ({{ points.length }}/30)</h2>
                    <button @click="clearPoints" class="text-xs text-red-500 hover:text-red-700 underline">æ¸…ç©ºåˆ—è¡¨</button>
                </div>
                <div class="bg-gray-50 rounded-lg p-2 max-h-60 overflow-y-auto border border-gray-200 shadow-inner">
                    <p v-if="points.length === 0" class="text-xs text-gray-400 text-center py-4">ğŸ‘† ç‚¹å‡»åœ°å›¾æ·»åŠ åæ ‡ç‚¹<br>æ”¯æŒæ‹–æ‹½è°ƒæ•´</p>
                    <div v-for="(p, index) in points" :key="index" class="flex flex-col mb-2 border-b last:border-0 pb-2 bg-white p-2 rounded shadow-sm">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-blue-600 mr-2 bg-blue-50 px-1.5 py-0.5 rounded">P{{ index + 1 }}</span>
                            <div class="flex items-center space-x-2 flex-1 justify-end">
                                <input type="color" v-model="p.color" class="shadow-sm">
                                <input type="text" v-model="p.color" class="text-[10px] border rounded px-1 py-0.5 w-14 font-mono text-gray-500 uppercase focus:outline-none focus:border-blue-500">
                            </div>
                        </div>
                        <div class="flex space-x-2">
                            <div class="flex-1 relative">
                                <span class="absolute left-1 top-1 text-[9px] text-gray-400">Lat</span>
                                <input type="number" step="0.001" v-model.number="p.lat" @input="updateMarkerPosition(index)" class="coord-input w-full border rounded pl-6 pr-1 py-0.5 bg-gray-50 focus:bg-white focus:outline-none focus:border-blue-400 text-right">
                            </div>
                            <div class="flex-1 relative">
                                <span class="absolute left-1 top-1 text-[9px] text-gray-400">Lon</span>
                                <input type="number" step="0.001" v-model.number="p.lng" @input="updateMarkerPosition(index)" class="coord-input w-full border rounded pl-6 pr-1 py-0.5 bg-gray-50 focus:bg-white focus:outline-none focus:border-blue-400 text-right">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <hr class="border-gray-100 mb-6">

            <div class="mb-6">
                <h2 class="block text-sm font-bold text-gray-800 mb-3 border-l-4 border-indigo-600 pl-2">3. ç»˜å›¾èŒƒå›´</h2>
                <div class="flex space-x-2 mb-3">
                    <button @click="enableDraw" :class="isDrawing ? 'bg-indigo-600 text-white ring-2 ring-indigo-300' : 'bg-white border border-gray-300 text-gray-700'" class="flex-1 py-2 rounded shadow-sm transition text-xs font-semibold hover:bg-gray-50">
                        {{ isDrawing ? 'âš¡ æ­£åœ¨æ¡†é€‰...' : 'ğŸ–±ï¸ é¼ æ ‡æ¡†é€‰' }}
                    </button>
                    <button @click="resetExtent" class="px-3 bg-white border border-gray-300 rounded shadow-sm hover:bg-gray-50 text-gray-600 text-xs">é‡ç½®</button>
                </div>
                <div class="bg-indigo-50/50 p-3 rounded border border-indigo-100">
                    <div class="grid grid-cols-2 gap-3">
                        <div><label class="text-[10px] text-gray-500 font-semibold block mb-0.5">Min Lon</label><input v-model.number="manualBounds.minLon" @keydown.enter.prevent="fillDefault('minLon', -180, $event)" type="number" step="0.1" placeholder="-180" class="coord-input w-full border border-gray-300 rounded px-2 py-1 focus:ring-2 focus:ring-indigo-200 focus:border-indigo-500 outline-none transition-all placeholder-gray-300"></div>
                        <div><label class="text-[10px] text-gray-500 font-semibold block mb-0.5">Max Lon</label><input v-model.number="manualBounds.maxLon" @keydown.enter.prevent="fillDefault('maxLon', 180, $event)" type="number" step="0.1" placeholder="180" class="coord-input w-full border border-gray-300 rounded px-2 py-1 focus:ring-2 focus:ring-indigo-200 focus:border-indigo-500 outline-none transition-all placeholder-gray-300"></div>
                        <div><label class="text-[10px] text-gray-500 font-semibold block mb-0.5">Min Lat</label><input v-model.number="manualBounds.minLat" @keydown.enter.prevent="fillDefault('minLat', -90, $event)" type="number" step="0.1" placeholder="-90" class="coord-input w-full border border-gray-300 rounded px-2 py-1 focus:ring-2 focus:ring-indigo-200 focus:border-indigo-500 outline-none transition-all placeholder-gray-300"></div>
                        <div><label class="text-[10px] text-gray-500 font-semibold block mb-0.5">Max Lat</label><input v-model.number="manualBounds.maxLat" @keydown.enter.prevent="fillDefault('maxLat', 90, $event)" type="number" step="0.1" placeholder="90" class="coord-input w-full border border-gray-300 rounded px-2 py-1 focus:ring-2 focus:ring-indigo-200 focus:border-indigo-500 outline-none transition-all placeholder-gray-300"></div>
                    </div>
                </div>
            </div>

            <div class="mb-8">
                <h2 class="block text-sm font-bold text-gray-800 mb-3 border-l-4 border-indigo-600 pl-2">4. æ ·å¼é…ç½®</h2>
                
                <div class="bg-gray-50 p-3 rounded border border-gray-200 flex items-center justify-between mb-3">
                    <div class="flex items-center">
                        <span class="text-xs text-gray-700 font-medium">æµ·æ´‹å¡«å……é¢œè‰²</span>
                    </div>
                    <div class="flex items-center">
                        <input type="checkbox" id="fillOcean" v-model="fillOcean" class="w-4 h-4 text-indigo-600 bg-white border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
                        <label for="fillOcean" class="ml-2 text-xs text-gray-700 cursor-pointer select-none">
                            {{ fillOcean ? 'é»‘è‰² (Dark)' : 'é€æ˜ (Default)' }}
                        </label>
                    </div>
                </div>

                <div class="bg-gray-50 p-3 rounded border border-gray-200">
                    <label class="block text-xs font-medium text-gray-700 mb-2">ç½‘æ ¼åˆ†è¾¨ç‡ (ç²¾åº¦/é€Ÿåº¦)</label>
                    <div class="grid grid-cols-3 gap-2">
                        <div @click="resolution = 'low'" :class="resolution === 'low' ? 'active' : 'bg-white text-gray-600 hover:bg-gray-50'" class="res-option cursor-pointer rounded py-2 px-1 text-center">
                            <div class="text-[10px] font-bold">å¿«é€Ÿ</div>
                            <div class="text-[8px] opacity-70">600x1200</div>
                        </div>
                        <div @click="resolution = 'medium'" :class="resolution === 'medium' ? 'active' : 'bg-white text-gray-600 hover:bg-gray-50'" class="res-option cursor-pointer rounded py-2 px-1 text-center">
                            <div class="text-[10px] font-bold">æ ‡å‡†</div>
                            <div class="text-[8px] opacity-70">1200x2400</div>
                        </div>
                        <div @click="resolution = 'high'" :class="resolution === 'high' ? 'active' : 'bg-white text-gray-600 hover:bg-gray-50'" class="res-option cursor-pointer rounded py-2 px-1 text-center">
                            <div class="text-[10px] font-bold">ç²¾ç»†</div>
                            <div class="text-[8px] opacity-70">2400x4800</div>
                        </div>
                    </div>
                </div>
            </div>

            <button @click="generateMap" :disabled="isLoading || points.length < 2" 
                    class="w-full bg-gradient-to-r from-indigo-600 to-blue-600 text-white py-3 rounded-lg shadow-lg hover:from-indigo-700 hover:to-blue-700 transition transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center font-bold tracking-wide">
                <span v-if="isLoading" class="loader mr-2 border-white border-t-transparent"></span>
                {{ isLoading ? 'æ¸²æŸ“è®¡ç®—ä¸­...' : 'ğŸš€ ç”Ÿæˆé«˜æ¸…åœ°å›¾' }}
            </button>
        </div>
    </div>

    <div class="flex-1 relative bg-gray-100 ml-96">
        <div class="map-switch">
            <div class="map-btn" :class="{active: mapType === 'OSM'}" @click="switchMapType('OSM')">OSM (WGS84)</div>
            <div class="map-btn" :class="{active: mapType === 'AMAP'}" @click="switchMapType('AMAP')">é«˜å¾· (GCJ02)</div>
        </div>

        <div id="leaflet-map"></div>
        <div v-if="resultImage" class="absolute inset-0 z-[1000] bg-black bg-opacity-90 flex items-center justify-center p-10 backdrop-blur-sm">
            <div class="bg-white p-2 rounded-lg shadow-2xl relative max-w-full max-h-full flex flex-col">
                <button @click="resultImage = null" class="absolute -top-10 right-0 text-white text-3xl font-bold hover:text-gray-300 transition">&times;</button>
                <img :src="resultImage" class="max-w-full max-h-[85vh] object-contain border border-gray-200 rounded-sm bg-gray-50">
                <div class="mt-3 flex justify-between items-center px-1">
                    <span class="text-xs text-gray-500">æ¸²æŸ“å®Œæˆ</span>
                    <a :href="resultImage" download="voronoi_map.png" class="bg-indigo-600 text-white px-6 py-2 rounded shadow hover:bg-indigo-700 text-sm font-medium transition">ä¸‹è½½ PNG</a>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const { createApp, ref, reactive, onMounted } = Vue;
const DEFAULT_PALETTE = ['#90EE90', '#F06C9B', '#F4A259', '#8FD3C8', '#FFFFE0', '#D3C8F0', '#F0D3C8', '#C8F0D3', '#FF6B6B', '#4ECDC4'];

// --- åæ ‡è½¬æ¢å·¥å…·å‡½æ•° (WGS84 <-> GCJ02) ---
const PI = 3.1415926535897932384626;
const a = 6378245.0;
const ee = 0.00669342162296594323;

function transformLat(x, y) {
    let ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
    ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
    ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;
    ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0;
    return ret;
}

function transformLon(x, y) {
    let ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
    ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
    ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;
    ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0;
    return ret;
}

// åˆ¤æ–­æ˜¯å¦åœ¨ä¸­å›½å¢ƒå†…
function outOfChina(lat, lon) {
    if (lon < 72.004 || lon > 137.8347) return true;
    if (lat < 0.8293 || lat > 55.8271) return true;
    return false;
}

// WGS-84 è½¬ GCJ-02 (OSM -> é«˜å¾·)
function wgs84togcj02(wgsLat, wgsLon) {
    if (outOfChina(wgsLat, wgsLon)) return [wgsLat, wgsLon];
    let dLat = transformLat(wgsLon - 105.0, wgsLat - 35.0);
    let dLon = transformLon(wgsLon - 105.0, wgsLat - 35.0);
    let radLat = wgsLat / 180.0 * PI;
    let magic = Math.sin(radLat);
    magic = 1 - ee * magic * magic;
    let sqrtMagic = Math.sqrt(magic);
    dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * PI);
    dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * PI);
    return [wgsLat + dLat, wgsLon + dLon];
}

// GCJ-02 è½¬ WGS-84 (é«˜å¾· -> OSM/åç«¯)
function gcj02towgs84(gcjLat, gcjLon) {
    if (outOfChina(gcjLat, gcjLon)) return [gcjLat, gcjLon];
    let dLat = transformLat(gcjLon - 105.0, gcjLat - 35.0);
    let dLon = transformLon(gcjLon - 105.0, gcjLat - 35.0);
    let radLat = gcjLat / 180.0 * PI;
    let magic = Math.sin(radLat);
    magic = 1 - ee * magic * magic;
    let sqrtMagic = Math.sqrt(magic);
    dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * PI);
    dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * PI);
    let mglat = gcjLat + dLat;
    let mglon = gcjLon + dLon;
    return [gcjLat * 2 - mglat, gcjLon * 2 - mglon];
}
// ------------------------------------

createApp({
    setup() {
        const points = ref([]);
        const manualBounds = reactive({ minLon: null, maxLon: null, minLat: null, maxLat: null });
        const fileInput = ref(null);
        const pluginInput = ref(null);
        const drawPlugin = ref(false);
        const fillOcean = ref(true);
        const resolution = ref('medium');
        const isLoading = ref(false);
        const resultImage = ref(null);
        const isDrawing = ref(false);
        const mapType = ref('OSM'); // é»˜è®¤ä½¿ç”¨ OSM
        
        let map;
        let tileLayer;
        let markersGroup;
        let markerInstances = [];
        let drawnItems; 
        let drawHandler;

        onMounted(() => { initLeafletMap(); });

        const fillDefault = (key, value, event) => {
            manualBounds[key] = value;
            const el = event.target;
            el.classList.add('input-flash');
            setTimeout(() => el.classList.remove('input-flash'), 300);
        };

        const initLeafletMap = () => {
            map = L.map('leaflet-map').setView([35.0, 105.0], 4);
            
            // é»˜è®¤åŠ è½½ OSM ç“¦ç‰‡
            tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                attribution: '&copy; OpenStreetMap', 
                maxZoom: 19 
            }).addTo(map);

            markersGroup = L.layerGroup().addTo(map);
            drawnItems = L.featureGroup().addTo(map);
            
            map.on('click', (e) => { if (!isDrawing.value) addPoint(e.latlng); });
            map.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                drawnItems.clearLayers();
                drawnItems.addLayer(layer);
                const bounds = layer.getBounds();
                manualBounds.minLon = parseFloat(bounds.getWest().toFixed(4));
                manualBounds.maxLon = parseFloat(bounds.getEast().toFixed(4));
                manualBounds.minLat = parseFloat(bounds.getSouth().toFixed(4));
                manualBounds.maxLat = parseFloat(bounds.getNorth().toFixed(4));
                setTimeout(() => { isDrawing.value = false; if(drawHandler) drawHandler.disable(); }, 300);
            });
        };

        // æ ¸å¿ƒï¼šåˆ‡æ¢åœ°å›¾å›¾å±‚
        const switchMapType = (type) => {
            if (mapType.value === type) return;

            // 1. åˆ‡æ¢åº•å›¾
            if (tileLayer) map.removeLayer(tileLayer);
            
            if (type === 'OSM') {
                tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap', maxZoom: 19
                }).addTo(map);
                
                // 2. è½¬æ¢åæ ‡: GCJ02 -> WGS84
                convertCoordinates(gcj02towgs84);

            } else if (type === 'AMAP') {
                // é«˜å¾·åœ°å›¾ç“¦ç‰‡ URL
                tileLayer = L.tileLayer('http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}', {
                    attribution: '&copy; Gaode', maxZoom: 19
                }).addTo(map);

                // 2. è½¬æ¢åæ ‡: WGS84 -> GCJ02
                convertCoordinates(wgs84togcj02);
            }

            mapType.value = type;
        };

        // æ‰¹é‡è½¬æ¢ç‚¹ä½å’ŒèŒƒå›´
        const convertCoordinates = (transformFunc) => {
            // A. è½¬æ¢ç‚¹ä½
            points.value.forEach((p, index) => {
                const [newLat, newLng] = transformFunc(p.lat, p.lng);
                p.lat = parseFloat(newLat.toFixed(6));
                p.lng = parseFloat(newLng.toFixed(6));
                
                // åŒæ­¥æ›´æ–°åœ°å›¾ä¸Šçš„ Marker
                if (markerInstances[index]) {
                    markerInstances[index].setLatLng([newLat, newLng]);
                }
            });

            // B. è½¬æ¢æ¡†é€‰èŒƒå›´ (å¦‚æœæœ‰å€¼)
            if (manualBounds.minLon !== null) {
                // ç®€å•å¤„ç†ï¼šåªè½¬æ¢è¥¿å—å’Œä¸œåŒ—ä¸¤ä¸ªè§’
                const [minLat, minLon] = transformFunc(manualBounds.minLat, manualBounds.minLon);
                const [maxLat, maxLon] = transformFunc(manualBounds.maxLat, manualBounds.maxLon);
                
                manualBounds.minLat = parseFloat(minLat.toFixed(4));
                manualBounds.minLon = parseFloat(minLon.toFixed(4));
                manualBounds.maxLat = parseFloat(maxLat.toFixed(4));
                manualBounds.maxLon = parseFloat(maxLon.toFixed(4));

                // å¦‚æœåœ°å›¾ä¸Šæœ‰æ¡†ï¼Œé‡ç»˜å®ƒ
                if (drawnItems.getLayers().length > 0) {
                    const rect = drawnItems.getLayers()[0];
                    rect.setBounds([
                        [minLat, minLon],
                        [maxLat, maxLon]
                    ]);
                }
            }
        };

        const validateFile = (event, inputRef) => {
            const file = event.target.files[0];
            if (!file) return;
            const validExtensions = ['.json', '.geojson'];
            if (!validExtensions.some(ext => file.name.toLowerCase().endsWith(ext))) {
                alert("æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼\nè¯·ä¸Šä¼  .json æˆ– .geojson æ ¼å¼çš„æ–‡ä»¶ã€‚");
                inputRef.value = ''; 
            }
        };

        const addPoint = (latlng) => {
            if (points.value.length >= 30) { alert("æœ€å¤šæ”¯æŒ 30 ä¸ªç‚¹"); return; }
            const defaultColor = DEFAULT_PALETTE[points.value.length % DEFAULT_PALETTE.length];
            const pointData = { lat: parseFloat(latlng.lat.toFixed(6)), lng: parseFloat(latlng.lng.toFixed(6)), color: defaultColor };
            points.value.push(pointData);
            const currentIndex = points.value.length - 1;
            const marker = L.marker([latlng.lat, latlng.lng], { draggable: true }).addTo(markersGroup);
            marker.bindTooltip(`P${currentIndex + 1}`, { permanent: true, direction: 'right' });
            marker.on('drag', (e) => {
                const newPos = e.target.getLatLng();
                points.value[currentIndex].lat = parseFloat(newPos.lat.toFixed(6));
                points.value[currentIndex].lng = parseFloat(newPos.lng.toFixed(6));
            });
            markerInstances.push(marker);
        };

        const updateMarkerPosition = (index) => {
            const p = points.value[index];
            const marker = markerInstances[index];
            if (marker && !isNaN(p.lat) && !isNaN(p.lng)) marker.setLatLng([p.lat, p.lng]);
        };

        const enableDraw = () => {
            if (isDrawing.value) return;
            isDrawing.value = true;
            drawnItems.clearLayers();
            Object.keys(manualBounds).forEach(k => manualBounds[k] = null);
            drawHandler = new L.Draw.Rectangle(map, { shapeOptions: { color: '#4F46E5', weight: 2 } });
            drawHandler.enable();
        };

        const resetExtent = () => {
            drawnItems.clearLayers();
            Object.keys(manualBounds).forEach(k => manualBounds[k] = null);
            if(drawHandler) drawHandler.disable();
            isDrawing.value = false;
        };

        const clearPoints = () => { markersGroup.clearLayers(); markerInstances = []; points.value = []; };

        const generateMap = async () => {
            if (!fileInput.value.files[0]) { alert("è¯·å…ˆä¸Šä¼ ä¸»åº•å›¾æ–‡ä»¶ï¼"); return; }
            if (drawPlugin.value && !pluginInput.value.files[0]) {
                alert("æ‚¨å‹¾é€‰äº†ç»˜åˆ¶è¾…åŠ©åœ°å›¾ï¼Œä½†æœªä¸Šä¼ å¯¹åº”æ–‡ä»¶ï¼"); return;
            }

            isLoading.value = true;
            const formData = new FormData();
            
            // --- æ ¸å¿ƒï¼šæ•°æ®æ¸…æ´— (ç»Ÿä¸€è½¬ä¸º WGS-84 å‘é€ç»™åç«¯) ---
            let submitPoints = JSON.parse(JSON.stringify(points.value)); // æ·±æ‹·è´
            let submitBounds = {...manualBounds};

            // å¦‚æœå½“å‰æ˜¯é«˜å¾·æ¨¡å¼ (GCJ02)ï¼Œå¿…é¡»è½¬å› WGS84
            if (mapType.value === 'AMAP') {
                console.log("æ£€æµ‹åˆ°é«˜å¾·æ¨¡å¼ï¼Œæ­£åœ¨è½¬æ¢æ•°æ®ä¸º WGS84...");
                // è½¬æ¢ç‚¹ä½
                submitPoints.forEach(p => {
                    const [wgsLat, wgsLng] = gcj02towgs84(p.lat, p.lng);
                    p.lat = wgsLat;
                    p.lng = wgsLng;
                });
                // è½¬æ¢èŒƒå›´
                if (submitBounds.minLon !== null) {
                    const [minLat, minLon] = gcj02towgs84(submitBounds.minLat, submitBounds.minLon);
                    const [maxLat, maxLon] = gcj02towgs84(submitBounds.maxLat, submitBounds.maxLon);
                    submitBounds.minLat = minLat; submitBounds.minLon = minLon;
                    submitBounds.maxLat = maxLat; submitBounds.maxLon = maxLon;
                }
            }

            // å‘é€æ•°æ®
            const pointsArray = submitPoints.map(p => [p.lat, p.lng]);
            formData.append("points", JSON.stringify(pointsArray));
            const colorsArray = submitPoints.map(p => p.color);
            formData.append("colors", JSON.stringify(colorsArray));
            
            let extentArray = null;
            if (submitBounds.minLon !== null && submitBounds.maxLon !== null && 
                submitBounds.minLat !== null && submitBounds.maxLat !== null) {
                extentArray = [submitBounds.minLon, submitBounds.maxLon, submitBounds.minLat, submitBounds.maxLat];
            }
            formData.append("extent", JSON.stringify(extentArray));
            
            formData.append("file", fileInput.value.files[0]);
            formData.append("draw_plugin", drawPlugin.value); 
            formData.append("fill_ocean", fillOcean.value);
            formData.append("resolution", resolution.value);
            
            if (pluginInput.value.files[0]) {
                formData.append("plugin_file", pluginInput.value.files[0]);
            }

            try {
                const response = await fetch("/generate-map", { method: "POST", body: formData });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || "è¯·æ±‚å¤±è´¥");
                }
                const blob = await response.blob();
                resultImage.value = URL.createObjectURL(blob);
            } catch (e) {
                alert("ç”Ÿæˆå¤±è´¥: " + e.message);
                console.error(e);
            } finally {
                isLoading.value = false;
            }
        };

        return {
            points, manualBounds, fileInput, pluginInput, drawPlugin, fillOcean, resolution,
            isLoading, resultImage, isDrawing, mapType,
            clearPoints, generateMap, enableDraw, resetExtent, validateFile, addPoint, updateMarkerPosition,
            fillDefault, switchMapType
        };
    }
}).mount('#app');
</script>
</body>
</html>